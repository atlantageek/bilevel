<!DOCTYPE html>
<meta charset="utf-8">
<style> /* set the CSS */

.arc text {
  font: 10px sans-serif;
  text-anchor: middle;
}

.arc path {
  stroke: #fff
}

</style>
<body>

<!-- load the d3.js library -->
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="data.js"></script>

<script>
let attributes = ['promoter','detractor','neutral'];

var root = d3.hierarchy(data, (d) => {return d.children});
function buildPaths(head, depth) {
  var result = [];
  var lvlRange = 1.0/depth;
  var startDepth = head.depth;
  var endDepth = startDepth + depth;
  var sum = 0;
  //Loop over each key and get a sum
  for (var key in head.value) {
    sum += head.value[key];
  }
  depthTrackerX=[0,0,0,0,0];
  head.each((elem) => {
    if (elem.depth >= endDepth) return;
    var baseX = elem.depth - startDepth;
    let elemSum = 0;
    for (var key in elem.value){
      elemSum += elem.value[key];
    }
    lastDepth = 0;
    for (var key in elem.value) {
      path = {
        x0: depthTrackerX[elem.depth],
        x1: elemSum/sum + depthTrackerX[elem.depth],
        y0: (elem.depth + lastDepth) * lvlRange,
        y1: (elem.depth  + elem.value[key]/elemSum + lastDepth) * lvlRange,
        fill: colors[key],
        debug: elem
      }
      result.push(path);
      lastDepth += elem.value[key]/elemSum;
    }
    depthTrackerX[elem.depth] +=elemSum/sum;

  })
  console.log(result);
  return result;
}

//root.sum(function(d) {return d.size;})
root.eachAfter(function(d) {
  if (d.hasOwnProperty('children')) {
      let e = d['children'].reduce((sumchild, child) => {
        result = {value:{}};
        if (sumchild == undefined) {
          sumchild.value={};
          attributes.forEach((e) =>{sumchild.value[e] = 0;})

        }
        if (sumchild.value == undefined) {
          sumchild.value={};
          attributes.forEach((e) =>{sumchild.value[e] = 0;});
        }
        attributes.forEach((e) =>{result.value[e] = sumchild.value[e] + child.value[e];});
        //sumchild.value['promoter'] +=child.value['promoter'];
        //sumchild.value['detractor'] +=child.value['detractor'];
        //sumchild.value['neutral'] +=child.value['neutral'];

        //sumchild.value = result.value;
        return result
      });
      d.value = e.value;

  }
  else {
    d.value = {'promoter': d.data.promoter, 'detractor': d.data.detractor, 'neutral': d.data.neutral};

  }
})
console.log(root);
// x = angular
// y = depth 0-1
var colors = {promoter:'green', detractor: 'red', neutral: 'blue'}


var margin = {top: 350, right: 480, bottom: 350, left: 480},
    radius = Math.min(margin.top, margin.right, margin.bottom, margin.left) - 10;

var x = d3.scaleLinear()
        .range([0, 2 * Math.PI]);
var y = d3.scaleSqrt()
        .range([0, radius]);
var depth_levels = 3;

var svg = d3.select("body").append("svg")
     .attr("width", margin.left +  margin.right )
     .attr("height", margin.top +  margin.bottom )
     .append("g")
     .attr("transform", "translate(" + margin.left + "," + margin.top + ")" );

var arc = d3.arc()
         .startAngle(function(d) { let v = Math.max(0, Math.min(2 * Math.PI, x(d.x0))); return v;})
         .endAngle(function(d) { let v = Math.max(0, Math.min(2 * Math.PI, x(d.x1))); return v;})
         .innerRadius(function(d) { let v = y(d.y0); console.log(v);return v;})
         .outerRadius(function(d) { let v = y(d.y1); console.log(v);return v;});
var dataPaths = buildPaths(root,3);
console.log(dataPaths);
//var center = svg.append("circle").attr("r", radius/3)
  //.on("click", zoomOut)
//  let v = d3.partition(root)//.nodes//.descendants();
var path = svg.selectAll("path").data(dataPaths)
  .enter().append("path").attr("d",arc).style("stroke","black").style("stroke-width","1").style("fill", function(d) { return d.fill});
  //.each(function(d) { this._current = updateArc(d);})
  //.on("click", zoomIn)



</script>



</body>
